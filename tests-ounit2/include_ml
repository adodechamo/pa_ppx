#use "topfind.camlp5";;
#require "findlib.internal";;
#require "compiler-libs.common" ;;
#require "ounit2";;
#require "fmt";;
#require "rresult";;
#require "pcre";;
#require "bos";;
#require "str";;
(*
#require "camlp5.pa_o";;
Pcaml.inter_phrases := Some ";;\n";;
*)
#require "camlp5.pa_r";;
Pcaml.inter_phrases := Some ";\n";;

(*
#require "camlp5.pr_o";;
*)

#require "camlp5.pr_r";;

(*
#require "camlp5.quotations";;
#require "camlp5.extfun";;
#require "camlp5.extend";;
#require "camlp5.phony_quotations" ;;
*)

#require "pa_ppx_testutils";;
#require "pa_ppx_base";;

open OUnit2 ;;
open Pa_ppx_testutils ;;
open Testutil ;;
open Testutil2 ;;
open Papr_util ;;

let pp_plexing_lexbuf b = Fmt.(pf stdout "<<%s>>" (Plexing.Lexbuf.get b)) ;;
#install_printer pp_plexing_lexbuf ;;

let nonws_re = Str.regexp "[^ \t\n]"
let not_ws s = match Str.search_forward nonws_re s 0 with _ -> true | exception Not_found -> false ;;

type ploc_verbosity = TERSE | COMMENT | LOCATION ;;

let verbose_ploc = ref TERSE ;;
let terse_pp_ploc (ploc : Ploc.t) =
  Format.print_string "<loc>"
;;
let comment_pp_ploc (ploc : Ploc.t) =
  let cs = Ploc.comment ploc in
  if not_ws cs then Format.printf "<loc \"%s\">" (String.escaped cs)
  else Format.print_string "<loc>"
;;
let verbose_pp_ploc (loc : Ploc.t) =
  let file_name = Ploc.file_name loc in
  let line_nb = Ploc.line_nb loc in
  let bol_pos = Ploc.bol_pos loc in
  let first_pos = Ploc.first_pos loc in
  let last_pos = Ploc.last_pos loc in
  let cs = Ploc.comment loc in
  if not_ws cs then
    Fmt.(pf stdout "<loc<\"%s\":%d (bol %d) %d-%d \"%s\">>"
           file_name line_nb bol_pos first_pos last_pos (String.escaped cs))
  else
    Fmt.(pf stdout "<loc<\"%s\":%d (bol %d) %d-%d>>"
           file_name line_nb bol_pos first_pos last_pos)
;;
let pp_ploc loc = match !verbose_ploc with 
    TERSE -> terse_pp_ploc loc
  | COMMENT -> comment_pp_ploc loc
  | LOCATION -> verbose_pp_ploc loc
;;
#install_printer pp_ploc;;

let pp_loc (loc : Location.t) = Format.print_string "<loc>" ;;
#install_printer pp_loc ;;

let pp_char_stream strm =
  let l = Stream.npeek !Toploop.max_printer_depth strm in
  Fmt.(pf stdout "<strm<[%a]>>" (list char) l)
;;
#install_printer pp_char_stream ;;

let pp_token_stream strm =
  let l = Stream.npeek !Toploop.max_printer_depth strm in
  let rec trim_eoi = function
    ("EOI",_ as x)::_ -> [x]
  | h::t -> h::(trim_eoi t)
  | [] -> []
  in 
  Fmt.(pf stdout "<strm<[%a]>>" (list ~sep:comma (parens (pair ~sep:comma (quote string) (quote string)))) (trim_eoi l))
;;
#install_printer pp_token_stream ;;

let lexbuf_contents lb =
  let open Lexing in
  let pos = lb.lex_curr_pos in
  let len = lb.lex_buffer_len - lb.lex_curr_pos in
  (Bytes.to_string (Bytes.sub lb.lex_buffer pos len))
;;

let pp_lexbuf lb =
  Format.print_string "#<lexbuf:<";
  Format.print_string (lexbuf_contents lb);
  Format.print_string ">>"
;;
#install_printer pp_lexbuf ;;

open Asttypes ;;
open Parsetree ;;
open Longident ;;

let pp_ctyp ty = Fmt.(pf stdout "#<ctyp< %s >>" (Eprinter.apply Pcaml.pr_ctyp Pprintf.empty_pc ty));;
let pp_expr ty = Fmt.(pf stdout "#<expr< %s >>" (Eprinter.apply Pcaml.pr_expr Pprintf.empty_pc ty));;

let pp_str_item ty = Fmt.(pf stdout "#<str_item< %s >>" (Eprinter.apply Pcaml.pr_str_item Pprintf.empty_pc ty));;
let pp_sig_item ty = Fmt.(pf stdout "#<str_item< %s >>" (Eprinter.apply Pcaml.pr_sig_item Pprintf.empty_pc ty));;
(*
let pp_ctyp ty = Fmt.(pf stdout "#<ctyp< %a >>" Pa_ppx_base.Pp_MLast.pp_ctyp ty);;
let pp_expr ty = Fmt.(pf stdout "#<expr< %a >>" Pa_ppx_base.Pp_MLast.pp_expr ty);;
*)
#install_printer pp_ctyp ;;
#install_printer pp_expr ;;
#install_printer pp_str_item ;;
#install_printer pp_sig_item ;;

print_string "================ START ================\n";; flush stdout ;;

#require "pa_ppx_deriving_plugins.params" ;;
#require "pa_ppx_deriving_plugins.eq" ;;
#directory "../pa_deriving.plugins";;

#require "ounit2";;
#require "pa_ppx_params_runtime";;
#use "test_deriving_params.pappx.ppo" ;;

{foo| 
      { dispatchers = {
(*
        migrate_option = {
          srctype = [%typ: 'a option]
        ; dsttype = [%typ: 'b option]
        ; subs = [ ([%typ: 'a], [%typ: 'b]) ]
        ; code = (fun subrw __dt__ __inh__ x -> Option.map (subrw __dt__ __inh__) x)
        }
      ; migrate_constant = {
          srctype = [%typ: constant]
        ; dsttype = [%typ: DST.Parsetree.constant]
        ; code = migrate_Asttypes_constant_Parsetree_constant
        }
      ; migrate_list = {
          srctype = [%typ: 'a list]
        ; dsttype = [%typ: 'b list]
        ; code = _migrate_list
        ; subs = [ ([%typ: 'a], [%typ: 'b]) ]
        }
      ; migrate_core_type_desc = {
          srctype = [%typ: core_type_desc]
        ; dsttype = [%typ: DST.Parsetree.core_type_desc]
        ; custom_branches_code = fun [
            Ptyp_arrow (v_0, v_1, v_2) ->
            let open DST.Parsetree in
            Ptyp_arrow
              (migrate_label_arg_label __dt__ __inh__ v_0,
               __dt__.migrate_core_type __dt__ __inh__ v_1,
               __dt__.migrate_core_type __dt__ __inh__ v_2)
            | Ptyp_object (v_0, v_1) ->
              let open DST.Parsetree in
              Ptyp_object
                (List.map (fun (v_0, v_1, v_2) ->
                     Otag(__dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_0),
                          __dt__.migrate_attributes __dt__ __inh__ v_1,
                          __dt__.migrate_core_type __dt__ __inh__ v_2)) v_0,
                 __dt__.migrate_closed_flag __dt__ __inh__ v_1)
                
            | Ptyp_poly (v_0, v_1) ->
              let open DST.Parsetree in
              Ptyp_poly
                (List.map (fun v_0 ->
                  __dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_0)) v_0,
                 __dt__.migrate_core_type __dt__ __inh__ v_1)
          ]
        }
      ; migrate_row_field = {
          srctype = [%typ: row_field]
        ; dsttype = [%typ: DST.Parsetree.row_field]
        ; custom_branches_code = fun [
              Rtag (v_0, v_1, v_2, v_3) ->
              let open DST.Parsetree in
              Rtag
                (__dt__.migrate_location_loc __dt__.migrate_label __dt__ __inh__ (wrap_loc __inh__ v_0),
                 __dt__.migrate_attributes __dt__ __inh__ v_1,
                 v_2,
                 List.map (__dt__.migrate_core_type __dt__ __inh__) v_3)
          ]
        }
      ; migrate_expression_desc = {
          srctype = [%typ: expression_desc]
        ; dsttype = [%typ: DST.Parsetree.expression_desc]
        ; custom_branches_code = fun [
              Pexp_fun (v_0, v_1, v_2, v_3) ->
              let open DST.Parsetree in
              Pexp_fun
                (migrate_label_arg_label __dt__ __inh__ v_0,
                 __dt__.migrate_option __dt__.migrate_expression __dt__ __inh__ v_1,
                 __dt__.migrate_pattern __dt__ __inh__ v_2,
                 __dt__.migrate_expression __dt__ __inh__ v_3)
            | Pexp_apply (v_0, v_1) ->
              let open DST.Parsetree in
              Pexp_apply
                (__dt__.migrate_expression __dt__ __inh__ v_0,
                 List.map (fun (v_0, v_1) ->
                     migrate_label_arg_label __dt__ __inh__ v_0,
                     __dt__.migrate_expression __dt__ __inh__ v_1) v_1)
            | Pexp_send (v_0, v_1) ->
              let open DST.Parsetree in
              Pexp_send
                (__dt__.migrate_expression __dt__ __inh__ v_0,
                 __dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_1))
            | Pexp_newtype (v_0, v_1) ->
              let open DST.Parsetree in
              Pexp_newtype
                (__dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_0),
                 __dt__.migrate_expression __dt__ __inh__ v_1)
          ]
        }
      ; migrate_constructor_declaration = {
          srctype = [%typ: constructor_declaration]
        ; dsttype = [%typ: DST.Parsetree.constructor_declaration]
        ; inherit_code = Some pcd_loc
        ; skip_fields = [ pcd_args ]
        ; custom_fields_code = {
            pcd_args =
              DST.Parsetree.Pcstr_tuple (List.map (__dt__.migrate_core_type __dt__ __inh__) pcd_args)
          }
        }
      ; migrate_extension_constructor_kind = {
          srctype = [%typ: extension_constructor_kind]
        ; dsttype = [%typ: DST.Parsetree.extension_constructor_kind]
        ; custom_branches_code = fun [
          Pext_decl (v_0, v_1) ->
          let open DST.Parsetree in
          Pext_decl
          (DST.Parsetree.Pcstr_tuple (List.map (__dt__.migrate_core_type __dt__ __inh__) v_0),
          Option.map (__dt__.migrate_core_type __dt__ __inh__) v_1)
          ]
          }
      ; migrate_class_type_desc = {
          srctype = [%typ: class_type_desc]
        ; dsttype = [%typ: DST.Parsetree.class_type_desc]
        ; custom_branches_code = fun [
          Pcty_arrow (v_0, v_1, v_2) ->
          let open DST.Parsetree in
          Pcty_arrow
          (migrate_label_arg_label __dt__ __inh__ v_0,
          __dt__.migrate_core_type __dt__ __inh__ v_1,
          __dt__.migrate_class_type __dt__ __inh__ v_2)
          ]
          }
      ; migrate_class_type_field_desc = {
          srctype = [%typ: class_type_field_desc]
        ; dsttype = [%typ: DST.Parsetree.class_type_field_desc]
        ; custom_branches_code = fun [
             Pctf_val v_0 ->
              let open DST.Parsetree in
              Pctf_val
                ((fun (v_0, v_1, v_2, v_3) ->
                    __dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_0),
                    __dt__.migrate_mutable_flag __dt__ __inh__ v_1,
                    __dt__.migrate_virtual_flag __dt__ __inh__ v_2,
                    __dt__.migrate_core_type __dt__ __inh__ v_3)
                   v_0)

            | Pctf_method v_0 ->
              let open DST.Parsetree in
              Pctf_method
                ((fun (v_0, v_1, v_2, v_3) ->
                    __dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v_0),
                    __dt__.migrate_private_flag __dt__ __inh__ v_1,
                    __dt__.migrate_virtual_flag __dt__ __inh__ v_2,
                    __dt__.migrate_core_type __dt__ __inh__ v_3) v_0)
          ]
        }
      ; migrate_class_expr_desc = {
          srctype = [%typ: class_expr_desc]
        ; dsttype = [%typ: DST.Parsetree.class_expr_desc]
        ; custom_branches_code = fun [
              Pcl_fun (v_0, v_1, v_2, v_3) ->
              let open DST.Parsetree in
              Pcl_fun
                (migrate_label_arg_label __dt__ __inh__ v_0,
                 Option.map (__dt__.migrate_expression __dt__ __inh__)  v_1,
                 __dt__.migrate_pattern __dt__ __inh__ v_2,
                 __dt__.migrate_class_expr __dt__ __inh__ v_3)
            | Pcl_apply (v_0, v_1) ->
              let open DST.Parsetree in
              Pcl_apply
                (__dt__.migrate_class_expr __dt__ __inh__ v_0,
                 List.map (fun (v_0, v_1) ->
                     migrate_label_arg_label __dt__ __inh__ v_0,
                     __dt__.migrate_expression __dt__ __inh__ v_1)
                   v_1)
          ]
        }
      ; migrate_class_field_desc = {
          srctype = [%typ: class_field_desc]
        ; dsttype = [%typ: DST.Parsetree.class_field_desc]
        ; custom_branches_code = fun [
              Pcf_inherit (v_0, v_1, v_2) ->
              let open DST.Parsetree in
              Pcf_inherit
                (__dt__.migrate_override_flag __dt__ __inh__ v_0,
                 __dt__.migrate_class_expr __dt__ __inh__ v_1,
                 Option.map (fun v -> __dt__.migrate_location_loc (fun _ _ x -> x) __dt__ __inh__ (wrap_loc __inh__ v)) v_2)
          ]
        }
      ; migrate_signature_item_desc = {
          srctype = [%typ: signature_item_desc]
        ; dsttype = [%typ: DST.Parsetree.signature_item_desc]
        ; custom_branches_code = fun [
              Psig_type v_0 ->
              let is_nonrec (attr,_) = attr.txt = "nonrec" in
              let rf = if (List.exists (fun td ->
                  List.exists is_nonrec td.ptype_attributes) v_0) then
                  DST.Asttypes.Nonrecursive
                else DST.Asttypes.Recursive in
              let open DST.Parsetree in
              Psig_type
                (rf, List.map (__dt__.migrate_type_declaration __dt__ __inh__) v_0) ]
        }
*)
      ; migrate_with_constraint = {
          srctype = [%typ: with_constraint]
        ; dsttype = [%typ: DST.Parsetree.with_constraint]
        ; custom_branches_code = function
            | Pwith_typesubst x0 ->
              let lid_loc = map_loc (fun x -> Lident x) x0.ptype_name in 
              let open DST.Parsetree in
              Pwith_typesubst
                (__dt__.migrate_location_loc __dt__.migrate_longident_t __dt__ __inh__ lid_loc,
                 __dt__.migrate_type_declaration __dt__ __inh__ x0)

            | Pwith_modsubst (v_0, v_1) ->
              let lid_loc = map_loc (fun x -> Lident x) v_0 in 
              let open DST.Parsetree in
              Pwith_modsubst
                (__dt__.migrate_location_loc __dt__.migrate_longident_t __dt__ __inh__ lid_loc,
                 __dt__.migrate_location_loc __dt__.migrate_longident_t __dt__ __inh__ v_1)

        }
      ; migrate_structure_item_desc = {
          srctype = [%typ: structure_item_desc]
        ; dsttype = [%typ: DST.Parsetree.structure_item_desc]
        ; custom_branches_code = fun [
              Pstr_type v_0 ->
              let is_nonrec (attr,_) = attr.txt = "nonrec" in
              let rf = if (List.exists (fun td ->
                  List.exists is_nonrec td.ptype_attributes) v_0) then
                  DST.Asttypes.Nonrecursive
                else DST.Asttypes.Recursive in
              let open DST.Parsetree in
              Pstr_type
                (rf, List.map (__dt__.migrate_type_declaration __dt__ __inh__) v_0) ]
        }
      ; migrate_printer = {
          srctype = [%typ: (Format.formatter -> unit)]
        ; dsttype = [%typ: (Format.formatter -> unit)]
        ; code = fun _ _ x -> x
        }
      ; migrate_exn = {
          srctype = [%typ: exn]
        ; dsttype = [%typ: exn]
        ; code = fun _ _ x -> x
        }
      ; migrate_out_value = {
          srctype = [%typ: out_value]
        ; dsttype = [%typ: DST.Outcometree.out_value]
        ; custom_branches_code = fun [
             Oval_string v_0 ->
              let open DST.Outcometree in
              Oval_string (v_0, max_int, Ostr_string) ]
        }
      ; migrate_out_variant = {
          srctype = [%typ: out_variant]
        ; dsttype = [%typ: DST.Outcometree.out_variant]
        ; custom_branches_code = fun [
             Ovar_name (v_0, v_1) ->
              let open DST.Outcometree in
              Ovar_typ
                (Otyp_constr
                   (__dt__.migrate_out_ident __dt__ __inh__ v_0,
                    List.map (__dt__.migrate_out_type __dt__ __inh__) v_1)) ]
        }
      ; migrate_out_sig_item = {
          srctype = [%typ: out_sig_item]
        ; dsttype = [%typ: DST.Outcometree.out_sig_item]
        ; custom_branches_code = fun [
              Osig_value (v_0, v_1, v_2) ->
              let open DST.Outcometree in
              Osig_value
                {oval_name = v_0
                ; oval_type = __dt__.migrate_out_type __dt__ __inh__ v_1
                ; oval_prims = v_2
                ; oval_attributes = []} ]
        }
      ; migrate_out_type_decl = {
          srctype = [%typ: out_type_decl]
        ; dsttype = [%typ: DST.Outcometree.out_type_decl]
        ; custom_fields_code = {
            otype_immediate = false
          ; otype_unboxed = false
          }
        }
      }
    }
    |foo} |> parse_expr ;;

(*
#load "test_deriving_params.cmo";;
open Test_deriving_params ;;
open MigrateParams ;;
*)
(*
;;; Local Variables: ***
;;; mode:tuareg ***
;;; End: ***

*)
