#use "topfind.camlp5";;
#require "findlib.internal";;
#require "compiler-libs.common" ;;
#require "ounit2";;
#require "fmt";;
#require "rresult";;
#require "pcre";;
#require "bos";;

(*
#require "camlp5.pa_op";;
Pcaml.inter_phrases := Some ";;\n";;
*)
#require "camlp5.pa_o";;
Pcaml.inter_phrases := Some ";\n";;

(*
#require "camlp5.pr_o";;
*)
#require "camlp5.pr_o";;

(*
#require "camlp5.pr_r";;
Pcaml.inter_phrases := Some ";\n";;
*)

#require "camlp5.quotations";;
#require "camlp5.extfun";;
(*
#require "camlp5.extend";;
#require "camlp5.phony_quotations" ;;
*)

#directory "../../camlp5/main";;
Exparser.optim := false ;;

#load "testutil.cmo";;
#load "testutil2.cmo";;

open OUnit2 ;;
open Testutil ;;
open Testutil2 ;;

let pp_plexing_lexbuf b = Fmt.(pf stdout "<<%s>>" (Plexing.Lexbuf.get b)) ;;
#install_printer pp_plexing_lexbuf ;;

let pp_loc (loc : Location.t) = Format.print_string "<loc>" ;;
#install_printer pp_loc ;;

let pp_char_stream strm =
  let l = Stream.npeek !Toploop.max_printer_depth strm in
  Fmt.(pf stdout "<strm<[%a]>>" (list char) l)
;;
#install_printer pp_char_stream ;;

let pp_token_stream strm =
  let l = Stream.npeek !Toploop.max_printer_depth strm in
  let rec trim_eoi = function
    ("EOI",_ as x)::_ -> [x]
  | h::t -> h::(trim_eoi t)
  | [] -> []
  in 
  Fmt.(pf stdout "<strm<[%a]>>" (list ~sep:comma (parens (pair ~sep:comma (quote string) (quote string)))) (trim_eoi l))
;;
#install_printer pp_token_stream ;;

let lexbuf_contents lb =
  let open Lexing in
  let pos = lb.lex_curr_pos in
  let len = lb.lex_buffer_len - lb.lex_curr_pos in
  (Bytes.to_string (Bytes.sub lb.lex_buffer pos len))
;;

let pp_lexbuf lb =
  Format.print_string "#<lexbuf:<";
  Format.print_string (lexbuf_contents lb);
  Format.print_string ">>"
;;
#install_printer pp_lexbuf ;;

print_string "================ START ================\n";; flush stdout ;;

#require "pa_ppx_pa_import";;

#require "pa_ppx_pa_deriving_plugins.show";;

open Asttypes ;;
open Parsetree ;;
open Longident ;;

#trace Pa_import.import_type ;;
#trace Pa_import.find_type ;;
#trace Pa_import.lookup_file ;;
#trace Bos.OS.File.exists ;;
#trace Pa_import.substitute_ctyp ;;
#trace Pa_import.string_list_of_expr ;;
#trace Pa_import.extend_renmap ;;

let dirs = [".";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/ocaml/compiler-libs";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/ocaml/compiler-libs";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/rresult";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/result";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/pcre";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/fmt";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/seq";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/ounit2";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/ounit2/advanced";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/ocaml";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/stdlib-shims";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/bytes";"/home/chet/Hack/Ocaml/GENERIC/4.10.0/lib/camlp5"];;
List.iter Pa_import.add_include (List.rev dirs) ;;


"test_ppx_import.ml" |> Fpath.v|> Bos.OS.File.read |> Rresult.R.get_ok |> PAPR.Implem.pa1 |> PAPR.Implem.pr |> print_string ;;

(*
;;; Local Variables: ***
;;; mode:tuareg ***
;;; End: ***

*)
